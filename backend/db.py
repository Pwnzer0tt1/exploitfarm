import ormar, sqlalchemy, databases, env, secrets
from pydantic import AwareDatetime
from pydantic import PlainSerializer, BaseModel
from typing import Dict, Any, TypeAlias, Annotated
from uuid import UUID, uuid4
from utils import datetime_now
from aiocache import cached
from env import RESET_DB_DANGEROUS
from hashlib import sha256
from models.enums import *
from typing import TypeVar, Union
from pydantic import BeforeValidator
from typing import Callable
from utils import *
import asyncio

T = TypeVar('T')

def extract_id_from_dict(x: Any) -> T:
    if isinstance(x, dict):
        return x["id"]
    if isinstance(x, BaseModel):
        return x.id
    return x

FkType = Annotated[T|Any, PlainSerializer(lambda x: extract_id_from_dict(x), return_type=T, when_used="always")]

dbconf = ormar.OrmarConfig(
    database = databases.Database(env.POSTGRES_URL),
    metadata = sqlalchemy.MetaData(),
    engine = sqlalchemy.create_engine(env.POSTGRES_URL),
)

EnvKey: TypeAlias = str
class Env(ormar.Model):
    ormar_config = dbconf.copy(tablename="envs")
    
    key: EnvKey = ormar.String(max_length=1024, primary_key=True)
    value: str|None = ormar.String(max_length=1024*1024, nullable=True)

MANUAL_CLIENT_ID = "manual"

ClientID: TypeAlias = str

def client_id_hashing(client_id: Any) -> ClientID:
    if isinstance(client_id, Union[dict, BaseModel]):
        client_id = extract_id_from_dict(client_id)
        if isinstance(client_id, dict):
            raise ValueError("Invalid client_id")
    try:
        if not isinstance(client_id, UUID):
            client_id = UUID(client_id)
    except Exception:
        return str(client_id)
    return "sha256-"+sha256(str(client_id).lower().encode()).hexdigest().lower()

def verify_and_parse_uuid(value: str) -> UUID:
    try:
        return client_id_hashing(UUID(value))
    except Exception:
        raise ValueError("Invalid UUID")

UnHashedClientID:TypeAlias = Annotated[str, BeforeValidator(verify_and_parse_uuid)]
# Auto hashing client_id if ClientID is a UnHashedClientID
class Client(ormar.Model):
    ormar_config = dbconf.copy(tablename="clients")
    
    id: ClientID = ormar.String(primary_key=True, max_length=1024)
    name: str|None = ormar.String(max_length=1024, nullable=True)
    created_at: AwareDatetime = ormar.DateTime(timezone=True, default=datetime_now)

ServiceID: TypeAlias = UUID
class Service(ormar.Model):
    ormar_config = dbconf.copy(tablename="services")
    
    id: ServiceID = ormar.UUID(default=uuid4, primary_key=True)
    name: str = ormar.String(max_length=1024)
    created_at: AwareDatetime = ormar.DateTime(timezone=True, default=datetime_now)

ExploitID: TypeAlias = UUID
class Exploit(ormar.Model):
    ormar_config = dbconf.copy(tablename="exploits")
    
    id: ExploitID = ormar.UUID(primary_key=True)
    name: str = ormar.String(max_length=1024)
    language: str = ormar.String(max_length=1024, choices=list(Language), default=Language.other.value)
    status: str = ormar.String(max_length=1024, choices=list(ExploitStatus), default=ExploitStatus.disabled.value)
    last_upadte: AwareDatetime = ormar.DateTime(timezone=True, default=datetime_now)
    created_at: AwareDatetime = ormar.DateTime(timezone=True, default=datetime_now)
    service: Service = ormar.ForeignKey(Service, related_name='exploits')
    created_by: Client = ormar.ForeignKey(Client, related_name='exploits_created')

TeamID: TypeAlias = int
class Team(ormar.Model):
    ormar_config = dbconf.copy(tablename="teams")
    
    id: TeamID = ormar.Integer(primary_key=True)
    name: str|None = ormar.String(max_length=1024, nullable=True)
    short_name: str|None = ormar.String(max_length=1024, nullable=True)
    host: str = ormar.String(max_length=1024, unique=True) #The host of the team (is a string because it can be an IP or a domain, but also in strange CTFs it can be something else)
    created_at: AwareDatetime = ormar.DateTime(timezone=True, default=datetime_now)

AttackExecutionID: TypeAlias = int
class AttackExecution(ormar.Model):
    ormar_config = dbconf.copy(tablename="attack_executions")
    
    id: AttackExecutionID = ormar.Integer(primary_key=True)
    start_time: AwareDatetime|None = ormar.DateTime(timezone=True, nullable=True) #Client generated, not affortable, useful for stats only
    end_time: AwareDatetime|None = ormar.DateTime(timezone=True, nullable=True) #Client generated, not affortable, useful for stats only
    status: str = ormar.String(max_length=1024, choices=list(AttackExecutionStatus), index=True)
    error: bytes|None = ormar.LargeBinary(max_length=1024*1024, nullable=True) #The output of the attack if it fails or no flags are found
    recieved_at: AwareDatetime = ormar.DateTime(timezone=True, default=datetime_now, index=True) #Server generated
    target: Team|None = ormar.ForeignKey(Team, related_name='attacks_executions', nullable=True, index=True)
    exploit: Exploit|None = ormar.ForeignKey(Exploit, related_name='executions', nullable=True, index=True)
    executed_by: Client|None = ormar.ForeignKey(Client, related_name='attacks_executions', nullable=True, index=True)
    
FlagID: TypeAlias = int
class Flag(ormar.Model):
    ormar_config = dbconf.copy(tablename="flags")
    
    id: FlagID = ormar.Integer(primary_key=True)
    flag: str = ormar.String(max_length=1024, unique=True)
    status: str = ormar.String(max_length=1024, choices=list(FlagStatus), default=FlagStatus.wait.value, index=True)
    last_submission_at: AwareDatetime|None = ormar.DateTime(timezone=True, nullable=True, index=True)
    status_text: str|None = ormar.String(max_length=1024, nullable=True)
    submit_attempts: int = ormar.Integer(default=0)
    attack: AttackExecution = ormar.ForeignKey(AttackExecution, related_name='flags')

SubmitterID: TypeAlias = int
class Submitter(ormar.Model):
    ormar_config = dbconf.copy(tablename="submitters")
    
    id: SubmitterID = ormar.Integer(primary_key=True)
    name: str = ormar.String(max_length=1024)
    code: bytes = ormar.LargeBinary(max_length=1024*1024)
    kargs: Dict[str, Dict[str, Any]] = ormar.JSON(default={})
    created_at: AwareDatetime = ormar.DateTime(timezone=True, default=datetime_now)

def dummy_decorator(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper


def get_dbenv_func(var_name: str, default_func:Callable|None = None, value_cached:bool=False):
    final_decorator = cached() if value_cached else dummy_decorator 
    @final_decorator
    async def FUNC() -> str:
        value = await Env.objects.get_or_none(key=var_name)
        value = value.value if value else None
        if value is None:
            value = default_func() if default_func else None
            await Env(key=var_name, value=value).save()
        return value
    return FUNC

APP_SECRET = get_dbenv_func("APP_SECRET", lambda: secrets.token_hex(32), value_cached=True)
AUTH_KEY = get_dbenv_func("AUTH_KEY", lambda: str(uuid4()))
SUBMITTER_ERROR_OUTPUT = get_dbenv_func("SUBMITTER_ERROR_OUTPUT", lambda: "")

async def __async_init_db():
    await connect_db()
    manual_client = await Client.objects.get_or_none(id=MANUAL_CLIENT_ID)
    if not manual_client:
        await Client(id=MANUAL_CLIENT_ID, name="Manual client").save()
    await close_db()

def init_db():
    if RESET_DB_DANGEROUS:
        dbconf.metadata.drop_all(dbconf.engine)
    dbconf.metadata.create_all(dbconf.engine)
    asyncio.run(__async_init_db())

async def connect_db():
    connection = await dbconf.database.connect()
    return connection


async def close_db():
    return await dbconf.database.disconnect()

transactional = dbconf.database.transaction()

if __name__ == "__main__":
    init_db()
    print("Database initialized.")