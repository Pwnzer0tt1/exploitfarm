import requests, os
from uuid import UUID
from typing import Dict, Any
from exploitfarm.utils.config import ClientConfig, ExploitConfig
from exploitfarm.utils import ExploitFarmClientError
import orjson
from datetime import datetime as dt
from exploitfarm.model import AttackMode, SetupStatus
from posixpath import join as urljoin
import platform, tarfile, tempfile
from . import calc_hash, exploit_tar_filter
from requests.models import Response
from requests_toolbelt import MultipartEncoder, MultipartEncoderMonitor

HTTP_TIMEOUT = float(os.getenv("XFARM_HTTP_TIMEOUT", 5))
PATH_OFFSET = os.getenv("XFARM_PATH_OFFSET", "/api")

def get_url(path:str, config: ClientConfig|None = None) -> str:
    protocol = "https" if config.server.https else "http"
    result = f"{protocol}://{config.server.address}:{config.server.port}"+urljoin("/", PATH_OFFSET, path[1:] if path.startswith('/') else path)
    if result.endswith("/"): result = result[:-1]
    return result

def jsonify(data: Any) -> str:
    return orjson.loads(orjson.dumps(data))

def get_session(auth:str|None|ClientConfig = None) -> requests.Session:
    res = requests.Session()
    if auth is not None:
        if isinstance(auth, str):
            res.headers.update({"Authorization": "Bearer "+auth})
        elif isinstance(auth, ClientConfig) and auth.server.auth_key is not None:
            res.headers.update({"Authorization": "Bearer "+auth.server.auth_key})
    return res

class ReqsError(Exception):pass

class EMPTY:pass

def requests_check(req: Response, get_response=True) -> Any:
    res = req.json()
    if str(req.status_code)[0] != "2":
        msg = res.get("message", None)
        try:
            resp = str(res.get("response", None))
        except Exception:
            resp = None
        if isinstance(msg, str):
            raise ReqsError(f"{msg}{f' ({resp})' if resp else ''}")
        else:
            raise ReqsError("Unknown error")
    if isinstance(res, dict) and "response" in res and get_response:
        return res["response"]
    return res

class Reqs:
    def __init__(self, config: ClientConfig):
        self.config = config
        self.session = get_session(config)
    
    def refresh_session(self, auth:str|ClientConfig|None = None):
        self.session = get_session(auth if auth else self.config)
    
    def status(self) -> Dict[str, Any]:
        res = requests_check(self.session.get(get_url("/status", self.config), timeout=HTTP_TIMEOUT))
        try:
            if res["whoami"] != "exploitfarm":
                raise Exception()
        except Exception:
            raise ReqsError("Invalid server")
        return res
    
    def submitters(self) -> Any:
        return requests_check(self.session.get(get_url("/submitters", self.config), timeout=HTTP_TIMEOUT))

    def teams(self) -> Any:
        return requests_check(self.session.get(get_url("/teams", self.config), timeout=HTTP_TIMEOUT))
    
    def clients(self) -> Any:
        return requests_check(self.session.get(get_url("/clients", self.config), timeout=HTTP_TIMEOUT))
    
    def flags(self) -> Any:
        return requests_check(self.session.get(get_url("/flags", self.config), timeout=HTTP_TIMEOUT))

    def exploits(self) -> Any:
        return requests_check(self.session.get(get_url("/exploits", self.config), timeout=HTTP_TIMEOUT))
    
    def services(self) -> Any:
        return requests_check(self.session.get(get_url("/services", self.config), timeout=HTTP_TIMEOUT))
    
    def new_submitter(self, data: dict) -> Any:
        return requests_check(self.session.post(get_url("/submitters", self.config), json=jsonify(data), timeout=HTTP_TIMEOUT))
    
    def delete_submitter(self, submitter_id:int) -> Any:
        return requests_check(self.session.delete(get_url(f"/submitters/{submitter_id}", self.config), timeout=HTTP_TIMEOUT))
    
    def test_submitter(self, submitter_id:int, flags:list[str]) -> Any:
        return requests_check(self.session.post(get_url(f"/submitters/{submitter_id}/test", self.config), json=flags, timeout=HTTP_TIMEOUT))
    
    def setup(self, data: dict) -> Any:
        return requests_check(self.session.post(get_url("/setup", self.config), json=jsonify(data), timeout=HTTP_TIMEOUT))
    
    def configure_server(self,
        flag_regex:str|EMPTY = EMPTY,
        tick_duration:int|EMPTY = EMPTY,
        submitter:int|EMPTY = EMPTY,
        start_time:dt|None|EMPTY = EMPTY,
        end_time:dt|None|EMPTY = EMPTY,
        attack_mode:AttackMode|EMPTY = EMPTY,
        loop_attack_delay:int|EMPTY = EMPTY,
        attack_time_tick_delay:int|EMPTY = EMPTY,
        flag_timeout:int|EMPTY = EMPTY,
        flag_submit_limit:int|None|EMPTY = EMPTY,
        submit_delay:int|EMPTY = EMPTY,
        submitter_timeout:int|EMPTY = EMPTY,
        authentication_required:bool|EMPTY = EMPTY,
        password_hash:str|None|EMPTY = EMPTY,
        setup_status:SetupStatus|EMPTY = EMPTY,
        set_running:bool = False
    ) -> Any:
        request = {
            "FLAG_REGEX": flag_regex,
            "START_TIME": start_time,
            "END_TIME": end_time,
            "TICK_DURATION": tick_duration,
            "ATTACK_MODE": attack_mode,
            "LOOP_ATTACK_DELAY": loop_attack_delay,
            "ATTACK_TIME_TICK_DELAY": attack_time_tick_delay,
            "FLAG_TIMEOUT": flag_timeout,
            "FLAG_SUBMIT_LIMIT": flag_submit_limit,
            "SUBMIT_DELAY": submit_delay,
            "SUBMITTER": submitter,
            "SUBMITTER_TIMEOUT": submitter_timeout,
            "AUTHENTICATION_REQUIRED": authentication_required,
            "PASSWORD_HASH": password_hash,
            "SETUP_STATUS": setup_status if not set_running else SetupStatus.RUNNING.value
        }
        request = {key: value for key, value in request.items() if value is not EMPTY}
        return self.setup(request)
    
    def login(self,password:str) -> str:
        try:
            return requests_check(self.session.post(get_url("/login", self.config), data={"grant_type":"password", "username": "user", "password": password}, timeout=HTTP_TIMEOUT))["access_token"]
        except KeyError:
            raise ReqsError("Failed to login")
    
    def authenicate(self, password:str, save:bool = True) -> str|None:
        auth_key = self.login(password)
        self.refresh_session(auth_key)
        self.config.server.auth_key = auth_key
        if save: self.config.write()
        return auth_key
    
    def new_client(self, data: dict) -> Any:
        return requests_check(self.session.post(get_url("/clients", self.config), json=jsonify(data), timeout=HTTP_TIMEOUT))
    
    def self_subscribe_client(self) -> Any:
        return self.new_client({"name": self.config.client_name, "id": self.config.client_id})
            
    def new_teams(self, data: list) -> Any:
        return requests_check(self.session.post(get_url("/teams", self.config), json=jsonify(data), timeout=HTTP_TIMEOUT))
    
    def new_service(self, data: dict) -> Any:
        return requests_check(self.session.post(get_url("/services", self.config), json=jsonify(data), timeout=HTTP_TIMEOUT))
    
    def new_exploit(self, data: dict) -> Any:
        return requests_check(self.session.post(get_url("/exploits", self.config), json=jsonify(data), timeout=HTTP_TIMEOUT))
    
    def submit_flags(self, data: list[dict], exploit:UUID|None = None) -> Any:
        if not exploit:
            return requests_check(self.session.post(get_url("/exploits/submit", self.config), json=jsonify(data), timeout=HTTP_TIMEOUT))
        else:
            return requests_check(self.session.post(get_url(f"/exploits/{exploit}/submit", self.config), json=jsonify(data), timeout=HTTP_TIMEOUT))

    def download_exploit_source_log(self, exploit_id:UUID) -> Any:
        return requests_check(self.session.get(get_url(f"/exploits/{exploit_id}/source", self.config), timeout=HTTP_TIMEOUT))

    def upload_exploit_source(self,
        path: str,
        message: str|None = None,
        os_type: str|None = None,
        arch: str|None = None,
        distro: str|None = None,
        force: bool = False,
        loading_callback: callable = None
    ):
        
        if os_type is None:
            os_type = platform.system()
        if distro is None:
            distro = platform.platform()
        if arch is None:
            arch = platform.machine()
        if message is None:
            message = ""
            
        expl_conf = ExploitConfig.read(path)
        if loading_callback:
            loading_callback("Downloading exploit history", None, None)
        logs = self.download_exploit_source_log(expl_conf.uuid)
        
        if not force:
            #Check hash not exists already
            calculated_hash = calc_hash(path)
            for log in logs:
                if log["hash"] == calculated_hash:
                    raise ExploitFarmClientError(f"Hash {calculated_hash} already exists")
        
        if loading_callback:
            loading_callback("Compressing exploit", None, None)
        with tempfile.SpooledTemporaryFile(1024*1024) as temp_file:
            with tarfile.open(fileobj=temp_file, mode="w:gz") as tar:
                tar.add(path, arcname=".", filter=exploit_tar_filter)
            temp_file.seek(0)
            
            encoder = MultipartEncoder(
                fields={
                    "file": ("explit_source.tar.gz", temp_file),
                    "os_type": os_type,
                    "arch": arch,
                    "distro": distro,
                    "message": message,
                    "pushed_by": str(self.config.client_id)
                }
            )
            
            def internal_callback(monitor):
                if loading_callback:
                    loading_callback("Uploading source", monitor.bytes_read, encoder.len)
            
            data_encoded = MultipartEncoderMonitor(encoder, internal_callback)
            
            return requests_check(
                self.session.post(get_url("/exploits/source", self.config),
                    data=data_encoded,
                    headers={'Content-Type': data_encoded.content_type}
                )
            )
            